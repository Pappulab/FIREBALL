'''
Part of the FIREBALL package!

Originally created on Sep 30, 2019 by Mina Farag
Updated Spring 2021 by Alex Holehouse and Mina Farag

'''

# import required packages
import importlib
import numpy as np
import pandas as pd
import math
from scipy import optimize

from .fireballexceptions import FireballException
from . import config

def build_theoretical_binodal(parameter_list, mode, regime):
    """
    Simple function that returns a dataframe with binodal dense/dilute arms. If the goal is simply to examine
    how binodals change as a function of the input parameters, this is the easiest way to do this, although 
    fundamentally this function is just a wrapper around fireball.full_binodal.binodal_maker().

    Parameters
    -----------    
    parameter_list : list
        list of parameters as defined in the given theory module (default is flory_huggins_3B)

    mode : str
        The name of the theory module to use. By default, fireball-fit and fireball-draw use flory_huggins_3B
        
    regime : str (either "low" or "high")
        If "low", then the algorithm assumes an upper critical system
        If "high", then the algorithm assumes a lower critical system
        By default, fireball-fit and fireball-draw use "low"

    Returns
    ---------
    (pd.dataframe, list, list)

        Returns a tuple of three elements:

        element 0: dataframe with the theoretical binodal.
        element 1: an ordered list of densities (in volume fraction) that map to the binodal
        element 2: an ordered list of temperatures that map to the binodal

    """

    return binodal_maker(parameter_list, mode, regime, None, None, outname=None, plotter=False)


def binodal_maker(parameter_list, mode, regime, dilute_array, dense_array, temperature_offset=None,
                  increment=None, outname=None, plotter=True):
    """
    Function for generating full binodals using the given theory method.

    Parameters
    --------------
    parameter_list : list
        list of parameters as defined in the given theory module (default is flory_huggins_3B)

    mode : str
        The name of the theory module to use. By default, fireball-fit and fireball-draw use flory_huggins_3B
        
    regime : str (either "low" or "high")
        If "low", then the algorithm assumes an upper critical system
        If "high", then the algorithm assumes a lower critical system
        By default, fireball-fit and fireball-draw use "low"

    dilute_array : np.ndarray (2xm)
        A 2D array where column 0 is temperature and column 1 is the dilute phase concentration of the
        binodal. This is automatically generated as output element 0 from the fireball.io.read_file() function

    dense_array : np.ndarray (2xm)
        A 2D array where column 0 is temperature and column 1 is the dense phase concentration of the
        binodal. This is automatically generated as output element 1 from the fireball.io.read_file() function

    temperature_offset : float
        Converts the y-axis units when plotting the data. Should bet set to 273.15 to convert the units
        from Kelvin to degrees Celsius. Should bet set to 0 to keep the units in Kelvin.

    increment : float
        The increment between consecutive values of the independent variable (temp, salt, etc.)

    outname : str or None
        Name of output file that is written containing binodal data. Note if set to None no file is written.
        Default = None

    plotter : bool
        Flag which, if set to true, ensures that the resulting binodal is plotted to screen and saved to
        a local file (binodal.pdf and binodal_log.pdf). Default = True

    Returns
    ---------
    (pd.dataframe, list, list)

        Returns a tuple of three elements:

        element 0: dataframe with the binodal fit and the experimental data (if provided).
        This contains all of the info generated by the binodal maker function
        
        element 1: an ordered list of densities (in volume fraction) that map to the binodal
        element 2: an ordered list of temperatures that map to the binodal

    """
    
    # The theory we are currently using. We will instantiate a Class based on this theory.
    # Some theories (FH) only require a single instantiation. Other theories (GCT) require
    # separate instantiations at each temperature.
    theory_module = importlib.import_module('fireball.theory.' + mode)

    # We define parameters that will be used in constructing the full binodal and plotting it alongside the data
    # starting_low_var is the lowest y-axis value on the binodal for a UCST system
    # starting_high_var is the highest y-axis value on the binodal for an LCST system
    # low_increment is the y-axis increment for each point of the binodal for a UCST system
    # high_increment is the y-axis increment for each point of the binodal for an LCST system
    # temperature_offset converts the y-axis units when plotting the data.
    # temperature_offset should bet set to 273.15 to convert the units from Kelvin to degrees Celsius
    # temperature_offset should bet set to 0 to keep the units in Kelvin
    starting_low_var = config.starting_low_var
    starting_high_var = config.starting_high_var
    if increment is None:
        low_increment = config.low_increment
        high_increment = config.high_increment
    else:
        low_increment = increment
        high_increment = increment
    if temperature_offset is None:
        temperature_offset = config.temperature_offset
    y_variable = config.y_variable
    y_label = config.y_label
    
    # Calculate the critical point. Method varies depending on the theory used
    if mode == 'GCT':
        # The second derivative of the free energy should have two zeros below the critical point
        # and no zeros above the critical point. These zeros correspond to the spinodal.
        # As the temperature increases, the points on the spinodal approach the critical point, allowing
        # us to estimate it.
        if regime == 'low':
            cur_temp = starting_low_var
            cur_crit_phi = False
            inc = 10
            while inc > .00001:    
                theory_class = theory_module.Theory_Class(parameter_list, cur_temp)
                cur_roots = theory_class.GCT_ddf.roots()
                if len(cur_roots) == 2:
                    cur_crit_T = cur_temp
                    cur_crit_phi = np.average(cur_roots)
                    cur_temp += inc
                elif cur_crit_phi:
                    inc /= 10
                    cur_temp -= inc * 9
                else:
                    raise FireballException('starting low var is above the critical temperature!!!')
            crit_phi = cur_crit_phi
            crit_var = cur_crit_T
        else:
            cur_temp = starting_high_var
            cur_crit_phi = False
            inc = 10
            while inc > .00001:    
                theory_class = theory_module.Theory_Class(parameter_list, cur_temp)
                cur_roots = theory_class.GCT_ddf.roots()
                if len(cur_roots) == 2:
                    cur_crit_T = cur_temp
                    cur_crit_phi = np.average(cur_roots)
                    cur_temp -= inc
                elif cur_crit_phi:
                    inc /= 10
                    cur_temp += inc * 9
                else:
                    raise FireballException('starting high var is below the critical temperature!!!')
            crit_phi = cur_crit_phi
            crit_var = cur_crit_T
    # GCT_Bivariate is an experimental theory module that should not be used to generate binodals!!!
    elif mode == 'GCT_Bivariate':
        theory_class = theory_module.Theory_Class(parameter_list)
        crit_point_fx = theory_class.build_critical_point_function()
        x0 = [0.1, 300]
        bounds = [[10 ** -7, theory_class.cur_max], [theory_class.min_var, theory_class.max_var]]
        tol = 100 ** -10
        method = "L-BFGS-B"        
        crit_point = optimize.minimize(crit_point_fx, x0, bounds = bounds, method = method, tol = tol)
        crit_phi = crit_point.x[0]
        crit_var = crit_point.x[1]
    else:
        # If an FH theory is called, we can directly calculate the critical point
        theory_class = theory_module.Theory_Class(parameter_list)
        # Function that builds the critical_phi_function. This internal function finds the value of 
        # crit_phi by solving for when dddf is zero. This value is independent of T.
        crit_phi_fx = theory_class.build_critical_phi_function()    
        crit_phi = optimize.root(crit_phi_fx, 0.01).x[0]
        # Find the value of crit_T by explicitly solving for when ddf is zero
        # This value is dependent on phi, so we substitute in the value for crit_phi
        crit_var_fx = theory_class.build_spinodal_function_var(crit_phi)
        crit_var = optimize.root(crit_var_fx, 300).x[0]
        
    # Initialize the first temperature at which we will find the binodal points
    # Construct the binodal by moving away from the critical point 
    if regime == 'low':
        regime = 0
        current_var = crit_var - low_increment
    elif regime == 'high':
        regime = 1
        current_var = crit_var + high_increment
    
    # Initialize the arrays we will need as we construct the binodal and spinodal
    # Populate them with the critical point
    spinodal_array = np.array(crit_phi)
    phi_array = np.array(crit_phi)
    var_array = np.array(crit_var - temperature_offset)
    error_set = []
    
    # Function spinodal is used to set bounds for the first phi values along the dilute and dense arms
    # The bounds for the following phi values are determined from the prior phi values
    if mode == 'GCT':
        theory_class = theory_module.Theory_Class(parameter_list, current_var)
        spinodal_function_phi = theory_class.build_spinodal_function_phi()
        dilute_high_bound = 0.99 * optimize.brentq(spinodal_function_phi, 0.00000001, crit_phi - 0.0000001)
        dense_low_bound = 1.01 * optimize.brentq(spinodal_function_phi, crit_phi + 0.0000001, theory_class.cur_max)
    else:
        spinodal_function_phi = theory_class.build_spinodal_function_phi(current_var)
        dilute_high_bound = 0.99 * optimize.brentq(spinodal_function_phi, 0.00000001, crit_phi - 0.0000001)
        dense_low_bound = 1.01 * optimize.brentq(spinodal_function_phi, crit_phi + 0.0000001, 0.99999)

    # This loop generates the desired points along the binodal
    binodal_loop_check = True
    while binodal_loop_check:
        
        # First we calculate the two spinodal concentrations at the given independent variable (temp, salt, etc) value
        # Functions binodal_function and jacobian are used to find the desired points on the binodal
        if mode == 'GCT':
            theory_class = theory_module.Theory_Class(parameter_list, current_var)
            spinodal_function_phi = theory_class.build_spinodal_function_phi()
            binodal_function = theory_class.build_binodal_function_no_phi()
            jacobian = theory_class.build_jacobian_function_no_phi()
            spinodal_low_phi = optimize.brentq(spinodal_function_phi, 10 ** -30, crit_phi - 0.0000001)
            spinodal_high_phi = optimize.brentq(spinodal_function_phi, crit_phi + 0.0000001, theory_class.cur_max)
        else:
            spinodal_function_phi = theory_class.build_spinodal_function_phi(current_var)
            binodal_function = theory_class.build_binodal_function_no_phi(current_var)
            jacobian = theory_class.build_jacobian_function_no_phi(current_var)
            spinodal_low_phi = optimize.brentq(spinodal_function_phi, 10 ** -30, crit_phi - 0.0000001)
            spinodal_high_phi = optimize.brentq(spinodal_function_phi, crit_phi + 0.0000001, 0.99999)
        
        # The binodal points must be outside of the spinodal and outside of the prior binodal points
        # Use whichever points give us a tighter boundary
        dilute_high_bound = np.min([dilute_high_bound, spinodal_low_phi])
        dense_low_bound = np.max([dense_low_bound, spinodal_high_phi])
                
        # Define our minimization parameters to find the desired points on the binodal
        if mode == 'GCT':
            # Determine an upper bound on the dense phase concentration based on GCT theory
            dense_high_bound_1 = (-1 * theory_class.GCT_T(current_var) / parameter_list[2] - 16 / 3) / (theory_class.F * np.sqrt(theory_class.N))
            dense_high_bound_2 = dense_low_bound * 2
            dense_high_bound_3 = theory_class.cur_max
            dense_high_bound = np.min([dense_high_bound_1, dense_high_bound_2, dense_high_bound_3])
            bounds = ((dense_low_bound, dense_high_bound), (10 ** -12, dilute_high_bound))
            x0 = [(dense_low_bound + dense_high_bound) / 2, dilute_high_bound * 0.95]
        else:
            bounds = ((dense_low_bound, .9999999), (10 ** -10, dilute_high_bound))
            x0 = [(dense_low_bound + 1) / 5, dilute_high_bound * 0.9]
        
        # Defining options for the minimization function
        tol = 100 ** -10
        method = "L-BFGS-B"
        # Perform the minimization
        binodal = optimize.minimize(binodal_function, x0, bounds = bounds, method = method, jac = jacobian, tol = tol)
        # Define new bounds for the next iteration based on the results of our last minimization
        dense_low_bound = phi_H = binodal.x[0]
        dilute_high_bound = phi_L = binodal.x[1]
        
        # Append our binodal and spinodal points to our arrays
        spinodal_array = np.append(spinodal_array, [spinodal_high_phi, spinodal_low_phi])
        phi_array = np.append(phi_array, [phi_H, phi_L])
        var_array = np.append(var_array, [current_var - temperature_offset, current_var - temperature_offset])
        
        # Append the error associated with these points on the binodal to error_set
        error_set.append(binodal.fun)
        
        # Increment current_var for the next iteration of the loop
        # If current_var is greater than starting_low_var for a UCST system, or less than starting_high_var
        # for an LCST system, we stop calculating binodal points
        if regime == 0:
            current_var = current_var - low_increment
            if current_var < starting_low_var:
                binodal_loop_check = False
        if regime == 1:
            current_var = current_var + high_increment
            if current_var > starting_high_var:
                binodal_loop_check = False

    # Create pandas dataframes from the binodal arrays and our data
    try:
        binodal_df = pd.DataFrame({'Spinodal Volume Fraction': spinodal_array, 'Binodal Volume Fraction': phi_array, y_variable: var_array})

        # build out vectors so we can draw connecting lines along binodal
        all_conc_spinodal = spinodal_array[1:][1::2][::-1].tolist()
        all_conc_spinodal.append(spinodal_array[0])
        all_conc_spinodal.extend(spinodal_array[1:][0::2].tolist())

        all_conc = phi_array[1:][1::2][::-1].tolist()
        all_conc.append(phi_array[0])
        all_conc.extend(phi_array[1:][0::2].tolist())
        
        all_var = var_array[1:][1::2][::-1].tolist()
        all_var.append(var_array[0])
        all_var.extend(var_array[1:][0::2].tolist())

    except ValueError:
        binodal_df = pd.DataFrame({'Spinodal Volume Fraction': [], 'Binodal Volume Fraction': [], y_variable: []})

        all_conc_spinodal = []
        all_conc = []
        all_var = []
    
    if outname is not None:
        # Write out the spinodal to a file
        with open(outname + '_spinodal.csv','w') as fh:
            for i in range(len(all_var)):
                fh.write('%3.8f, %3.3f\n' % (all_conc_spinodal[i], all_var[i]))
        # Write out the binodal to a file
        with open(outname + '_binodal.csv','w') as fh:
            for i in range(len(all_var)):
                fh.write('%3.12f, %3.3f\n' % (all_conc[i], all_var[i]))

    if dilute_array is not None:
        our_df = pd.DataFrame(np.append(dilute_array - [0, temperature_offset, 0], dense_array - [0, temperature_offset, 0], axis=0), columns = ['Binodal Volume Fraction', y_variable, 'Binodal Volume Fraction Error'])
        # Concatenate the dataframes and create a new column describing if the data is from the binodal or original data
        full_frame = pd.concat([binodal_df.assign(dataset = 'binodal'), our_df.assign(dataset = 'data')])        
    else:
        full_frame = binodal_df.assign(dataset = 'binodal')

    # if no plotting just return
    if plotter is False:
        return (full_frame, all_conc, all_var)

    # <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
    # local imports are not (in general) recommended, but this means that we only import these libraries if 
    # we try and plot. This has the advantage that we can run this code on a headless server where (lack of) GTK backends 
    # might make importing mpl or sns hard
    import matplotlib.pyplot as plt
    import seaborn as sns

    # Graph, save, and show the data with the binodal
    # ax1 shows the data on a linear scale
    # ax2 shows the data on a semi-log scale
    fig = plt.figure(figsize=(12,5))
    gs = fig.add_gridspec(1, 2)
    ax1 = fig.add_subplot(gs[0, 0])
    ax2 = fig.add_subplot(gs[0, 1])

    ax1.set(xlabel='Volume Fraction', ylabel = y_label)
    ax2.set(xlabel='Volume Fraction', ylabel = y_label)
    
    #===========================================================================
    # ##These lines are used to plot the phase diagrams in the same way as in Raos and Allegra, J. Chem Phys 1996
    # ##This allows comparisons with GCT if desired
    # reduced_x = [np.sqrt(theory_class.N) * x for x in binodal_df['Binodal Volume Fraction']]
    # reduced_x_spinodal = [np.sqrt(theory_class.N) * x for x in binodal_df['Spinodal Volume Fraction']]
    # reduced_y = [(y + temperature_offset - parameter_list[0]) / (y + temperature_offset) * parameter_list[1] * np.sqrt(theory_class.N) for y in binodal_df[y_variable]]
    # x_loci = np.linspace(0, 8, 1000)
    # y_loci = [-1 * parameter_list[2] * (theory_class.F * x + 16/3) for x in x_loci]
    # ax1.set_xlim(0, 8)
    # ax1.set_ylim(-.6, 0)
    # ax1.errorbar(x = reduced_x, y = reduced_y, fmt='.', color = sns.color_palette()[0], capsize=2, markersize=10, markeredgewidth=0.5, markeredgecolor='white', label='binodal')
    # ax1.errorbar(x = reduced_x_spinodal, y = reduced_y, fmt='.', color = sns.color_palette()[1], capsize=2, markersize=10, markeredgewidth=0.5, markeredgecolor='white', label='spinodal')
    # ax1.errorbar(x = x_loci, y = y_loci, fmt='-', color = sns.color_palette()[2], capsize=2, markersize=10, markeredgewidth=0.5, markeredgecolor='white', label='binodal')
    #===========================================================================
    
    ax1.errorbar(x = binodal_df['Binodal Volume Fraction'], y = binodal_df[y_variable], fmt='.', color = sns.color_palette()[0], capsize=2, markersize=10, markeredgewidth=0.5, markeredgecolor='white', label='binodal')
    if dilute_array is not None:
        if our_df['Binodal Volume Fraction Error'].isnull().all():
            ax1.errorbar(x = our_df['Binodal Volume Fraction'], y = our_df[y_variable], fmt='^', color=sns.color_palette()[1], ecolor='black', capsize=2, markersize=8, markeredgewidth=0.5, markeredgecolor='white', label='data')
        else:
            ax1.errorbar(x = our_df['Binodal Volume Fraction'], y = our_df[y_variable], xerr = our_df['Binodal Volume Fraction Error'], fmt='^', color=sns.color_palette()[1], ecolor='black', capsize=2, markersize=8, markeredgewidth=0.5, markeredgecolor='white', label='data')
    ax1.legend(loc='upper right')
    
    ax2.set(xscale="log")
    #ax2.set(xlim=(.000001, 1))
    ax2.errorbar(x = binodal_df['Binodal Volume Fraction'], y = binodal_df[y_variable], fmt='.', color = sns.color_palette()[0], capsize=2, markersize=10, markeredgewidth=0.5, markeredgecolor='white', label='binodal')
    if dilute_array is not None:
        if our_df['Binodal Volume Fraction Error'].isnull().all():
            ax2.errorbar(x = our_df['Binodal Volume Fraction'], y = our_df[y_variable], fmt='^', color=sns.color_palette()[1], ecolor='black', capsize=2, markersize=8, markeredgewidth=0.5, markeredgecolor='white', label='data')
        else:
            ax2.errorbar(x = our_df['Binodal Volume Fraction'], y = our_df[y_variable], xerr = our_df['Binodal Volume Fraction Error'],  fmt='^', color=sns.color_palette()[1], ecolor='black', capsize=2, markersize=8, markeredgewidth=0.5, markeredgecolor='white', label='data')
    ax2.legend(loc='upper left')
    
    plt.tight_layout()
    plt.savefig('binodal.pdf', bbox_inches='tight')
    plt.show()

    return (full_frame, all_conc, all_var)
    
